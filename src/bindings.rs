// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod near {
    pub mod rpc {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod api {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            pub fn view(
                contract_id: &str,
                method_name: &str,
                args_json: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = contract_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = method_name;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = args_json;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api")]
                    unsafe extern "C" {
                        #[link_name = "view"]
                        fn wit_import4(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import4(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import4(
                            ptr0.cast_mut(),
                            len0,
                            ptr1.cast_mut(),
                            len1,
                            ptr2.cast_mut(),
                            len2,
                            ptr3,
                        )
                    };
                    let l5 = *ptr3.add(0).cast::<*mut u8>();
                    let l6 = *ptr3
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len7 = l6;
                    let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                    let l8 = *ptr3
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l9 = *ptr3
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len10 = l9;
                    let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);
                    let result11 = (_rt::string_lift(bytes7), _rt::string_lift(bytes10));
                    result11
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn view_account(account_id: &str) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = account_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api")]
                    unsafe extern "C" {
                        #[link_name = "view-account"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = *ptr1.add(0).cast::<*mut u8>();
                    let l4 = *ptr1
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    let l6 = *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *ptr1
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    let result9 = (_rt::string_lift(bytes5), _rt::string_lift(bytes8));
                    result9
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn view_access_key(
                account_id: &str,
                public_key: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = account_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = public_key;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api")]
                    unsafe extern "C" {
                        #[link_name = "view-access-key"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = *ptr2.add(0).cast::<*mut u8>();
                    let l5 = *ptr2
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *ptr2
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let result10 = (_rt::string_lift(bytes6), _rt::string_lift(bytes9));
                    result10
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn block(finality_or_block_id: &str) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = finality_or_block_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api")]
                    unsafe extern "C" {
                        #[link_name = "block"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = *ptr1.add(0).cast::<*mut u8>();
                    let l4 = *ptr1
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    let l6 = *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *ptr1
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    let result9 = (_rt::string_lift(bytes5), _rt::string_lift(bytes8));
                    result9
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn gas_price() -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api")]
                    unsafe extern "C" {
                        #[link_name = "gas-price"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len4 = l3;
                    let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                    let l5 = *ptr0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l6 = *ptr0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len7 = l6;
                    let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                    let result8 = (_rt::string_lift(bytes4), _rt::string_lift(bytes7));
                    result8
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn send_tx(
                signed_tx_base64: &str,
                wait_until: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = signed_tx_base64;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = wait_until;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api")]
                    unsafe extern "C" {
                        #[link_name = "send-tx"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = *ptr2.add(0).cast::<*mut u8>();
                    let l5 = *ptr2
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *ptr2
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let result10 = (_rt::string_lift(bytes6), _rt::string_lift(bytes9));
                    result10
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn raw(method: &str, params_json: &str) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = method;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = params_json;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api")]
                    unsafe extern "C" {
                        #[link_name = "raw"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = *ptr2.add(0).cast::<*mut u8>();
                    let l5 = *ptr2
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *ptr2
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let result10 = (_rt::string_lift(bytes6), _rt::string_lift(bytes9));
                    result10
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Call a contract method with explicit signer
            /// signer-id: the account to sign as
            /// signer-key: the private key in NEAR format (ed25519:base58...)
            /// Returns (tx_hash, error)
            pub fn call(
                signer_id: &str,
                signer_key: &str,
                receiver_id: &str,
                method_name: &str,
                args_json: &str,
                deposit_yocto: &str,
                gas: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = signer_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = signer_key;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = receiver_id;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let vec3 = method_name;
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    let vec4 = args_json;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    let vec5 = deposit_yocto;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    let vec6 = gas;
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api")]
                    unsafe extern "C" {
                        #[link_name = "call"]
                        fn wit_import8(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import8(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import8(
                            ptr0.cast_mut(),
                            len0,
                            ptr1.cast_mut(),
                            len1,
                            ptr2.cast_mut(),
                            len2,
                            ptr3.cast_mut(),
                            len3,
                            ptr4.cast_mut(),
                            len4,
                            ptr5.cast_mut(),
                            len5,
                            ptr6.cast_mut(),
                            len6,
                            ptr7,
                        )
                    };
                    let l9 = *ptr7.add(0).cast::<*mut u8>();
                    let l10 = *ptr7
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len11 = l10;
                    let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);
                    let l12 = *ptr7
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l13 = *ptr7
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len14 = l13;
                    let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);
                    let result15 = (
                        _rt::string_lift(bytes11),
                        _rt::string_lift(bytes14),
                    );
                    result15
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Transfer NEAR tokens with explicit signer
            /// signer-id: the account to sign as
            /// signer-key: the private key in NEAR format (ed25519:base58...)
            /// Returns (tx_hash, error)
            pub fn transfer(
                signer_id: &str,
                signer_key: &str,
                receiver_id: &str,
                amount_yocto: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = signer_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = signer_key;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = receiver_id;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let vec3 = amount_yocto;
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api")]
                    unsafe extern "C" {
                        #[link_name = "transfer"]
                        fn wit_import5(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import5(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import5(
                            ptr0.cast_mut(),
                            len0,
                            ptr1.cast_mut(),
                            len1,
                            ptr2.cast_mut(),
                            len2,
                            ptr3.cast_mut(),
                            len3,
                            ptr4,
                        )
                    };
                    let l6 = *ptr4.add(0).cast::<*mut u8>();
                    let l7 = *ptr4
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    let l9 = *ptr4
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l10 = *ptr4
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len11 = l10;
                    let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);
                    let result12 = (_rt::string_lift(bytes8), _rt::string_lift(bytes11));
                    result12
                }
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    extern crate alloc as alloc_crate;
}
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:near:rpc:bot-father:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 617] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xe8\x03\x01A\x02\x01\
A\x02\x01B\x13\x01o\x02ss\x01@\x03\x0bcontract-ids\x0bmethod-names\x09args-jsons\
\0\0\x04\0\x04view\x01\x01\x01@\x01\x0aaccount-ids\0\0\x04\0\x0cview-account\x01\
\x02\x01@\x02\x0aaccount-ids\x0apublic-keys\0\0\x04\0\x0fview-access-key\x01\x03\
\x01@\x01\x14finality-or-block-ids\0\0\x04\0\x05block\x01\x04\x01@\0\0\0\x04\0\x09\
gas-price\x01\x05\x01@\x02\x10signed-tx-base64s\x0await-untils\0\0\x04\0\x07send\
-tx\x01\x06\x01@\x02\x06methods\x0bparams-jsons\0\0\x04\0\x03raw\x01\x07\x01@\x07\
\x09signer-ids\x0asigner-keys\x0breceiver-ids\x0bmethod-names\x09args-jsons\x0dd\
eposit-yoctos\x03gass\0\0\x04\0\x04call\x01\x08\x01@\x04\x09signer-ids\x0asigner\
-keys\x0breceiver-ids\x0camount-yoctos\0\0\x04\0\x08transfer\x01\x09\x03\0\x0cne\
ar:rpc/api\x05\0\x04\0\x13near:rpc/bot-father\x04\0\x0b\x10\x01\0\x0abot-father\x03\
\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-\
bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
