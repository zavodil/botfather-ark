// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod near {
    pub mod rpc {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod api {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            /// ==================== Query Methods (view functions) ====================
            /// Call a view function on a smart contract
            /// finality-or-block: "final", "optimistic", block height (e.g. "12345"), or block hash
            /// Empty string = "final" (default)
            pub fn view(
                contract_id: &str,
                method_name: &str,
                args_json: &str,
                finality_or_block: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = contract_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = method_name;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = args_json;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let vec3 = finality_or_block;
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "view"]
                        fn wit_import5(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import5(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import5(
                            ptr0.cast_mut(),
                            len0,
                            ptr1.cast_mut(),
                            len1,
                            ptr2.cast_mut(),
                            len2,
                            ptr3.cast_mut(),
                            len3,
                            ptr4,
                        )
                    };
                    let l6 = *ptr4.add(0).cast::<*mut u8>();
                    let l7 = *ptr4
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    let l9 = *ptr4
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l10 = *ptr4
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len11 = l10;
                    let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);
                    let result12 = (_rt::string_lift(bytes8), _rt::string_lift(bytes11));
                    result12
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get account information (balance, storage, code hash)
            /// finality-or-block: "final", "optimistic", block height, or block hash (empty = "final")
            pub fn view_account(
                account_id: &str,
                finality_or_block: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = account_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = finality_or_block;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "view-account"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = *ptr2.add(0).cast::<*mut u8>();
                    let l5 = *ptr2
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *ptr2
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let result10 = (_rt::string_lift(bytes6), _rt::string_lift(bytes9));
                    result10
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get access key information (nonce, permission, block hash)
            /// finality-or-block: "final", "optimistic", block height, or block hash (empty = "final")
            pub fn view_access_key(
                account_id: &str,
                public_key: &str,
                finality_or_block: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = account_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = public_key;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = finality_or_block;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "view-access-key"]
                        fn wit_import4(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import4(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import4(
                            ptr0.cast_mut(),
                            len0,
                            ptr1.cast_mut(),
                            len1,
                            ptr2.cast_mut(),
                            len2,
                            ptr3,
                        )
                    };
                    let l5 = *ptr3.add(0).cast::<*mut u8>();
                    let l6 = *ptr3
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len7 = l6;
                    let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                    let l8 = *ptr3
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l9 = *ptr3
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len10 = l9;
                    let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);
                    let result11 = (_rt::string_lift(bytes7), _rt::string_lift(bytes10));
                    result11
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get all access keys for an account
            /// finality-or-block: "final", "optimistic", block height, or block hash (empty = "final")
            pub fn view_access_key_list(
                account_id: &str,
                finality_or_block: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = account_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = finality_or_block;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "view-access-key-list"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = *ptr2.add(0).cast::<*mut u8>();
                    let l5 = *ptr2
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *ptr2
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let result10 = (_rt::string_lift(bytes6), _rt::string_lift(bytes9));
                    result10
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get contract WASM code
            /// finality-or-block: "final", "optimistic", block height, or block hash (empty = "final")
            pub fn view_code(
                account_id: &str,
                finality_or_block: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = account_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = finality_or_block;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "view-code"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = *ptr2.add(0).cast::<*mut u8>();
                    let l5 = *ptr2
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *ptr2
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let result10 = (_rt::string_lift(bytes6), _rt::string_lift(bytes9));
                    result10
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get contract state (all keys with prefix)
            /// prefix-base64: prefix in base64 (empty string = all keys)
            /// finality-or-block: "final", "optimistic", block height, or block hash (empty = "final")
            pub fn view_state(
                account_id: &str,
                prefix_base64: &str,
                finality_or_block: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = account_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = prefix_base64;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = finality_or_block;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "view-state"]
                        fn wit_import4(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import4(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import4(
                            ptr0.cast_mut(),
                            len0,
                            ptr1.cast_mut(),
                            len1,
                            ptr2.cast_mut(),
                            len2,
                            ptr3,
                        )
                    };
                    let l5 = *ptr3.add(0).cast::<*mut u8>();
                    let l6 = *ptr3
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len7 = l6;
                    let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                    let l8 = *ptr3
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l9 = *ptr3
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len10 = l9;
                    let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);
                    let result11 = (_rt::string_lift(bytes7), _rt::string_lift(bytes10));
                    result11
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// ==================== Block Methods ====================
            /// Get block information
            /// finality-or-block: "final", "optimistic", block height (e.g. "12345"), or block hash
            pub fn block(finality_or_block: &str) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = finality_or_block;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "block"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = *ptr1.add(0).cast::<*mut u8>();
                    let l4 = *ptr1
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    let l6 = *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *ptr1
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    let result9 = (_rt::string_lift(bytes5), _rt::string_lift(bytes8));
                    result9
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get chunk information
            /// chunk-id-or-block-shard: chunk ID OR "block_id,shard_id" (e.g. "12345,0")
            pub fn chunk(chunk_id_or_block_shard: &str) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = chunk_id_or_block_shard;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "chunk"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = *ptr1.add(0).cast::<*mut u8>();
                    let l4 = *ptr1
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    let l6 = *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *ptr1
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    let result9 = (_rt::string_lift(bytes5), _rt::string_lift(bytes8));
                    result9
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get changes in a block
            /// finality-or-block: "final", "optimistic", block height, or block hash
            pub fn changes(finality_or_block: &str) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = finality_or_block;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "changes"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = *ptr1.add(0).cast::<*mut u8>();
                    let l4 = *ptr1
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    let l6 = *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *ptr1
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    let result9 = (_rt::string_lift(bytes5), _rt::string_lift(bytes8));
                    result9
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// ==================== Transaction Methods ====================
            /// Send a signed transaction
            /// wait-until: "NONE", "INCLUDED", "EXECUTED_OPTIMISTIC" (default), "INCLUDED_FINAL", "EXECUTED", "FINAL"
            /// Empty string = "EXECUTED_OPTIMISTIC"
            pub fn send_tx(
                signed_tx_base64: &str,
                wait_until: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = signed_tx_base64;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = wait_until;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "send-tx"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = *ptr2.add(0).cast::<*mut u8>();
                    let l5 = *ptr2
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *ptr2
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let result10 = (_rt::string_lift(bytes6), _rt::string_lift(bytes9));
                    result10
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get transaction status by hash
            /// wait-until: same as send-tx (empty = "EXECUTED_OPTIMISTIC")
            pub fn tx_status(
                tx_hash: &str,
                sender_account_id: &str,
                wait_until: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = tx_hash;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = sender_account_id;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = wait_until;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "tx-status"]
                        fn wit_import4(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import4(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import4(
                            ptr0.cast_mut(),
                            len0,
                            ptr1.cast_mut(),
                            len1,
                            ptr2.cast_mut(),
                            len2,
                            ptr3,
                        )
                    };
                    let l5 = *ptr3.add(0).cast::<*mut u8>();
                    let l6 = *ptr3
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len7 = l6;
                    let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                    let l8 = *ptr3
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l9 = *ptr3
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len10 = l9;
                    let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);
                    let result11 = (_rt::string_lift(bytes7), _rt::string_lift(bytes10));
                    result11
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get receipt by ID
            pub fn receipt(receipt_id: &str) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = receipt_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "receipt"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = *ptr1.add(0).cast::<*mut u8>();
                    let l4 = *ptr1
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    let l6 = *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *ptr1
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    let result9 = (_rt::string_lift(bytes5), _rt::string_lift(bytes8));
                    result9
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Call a contract method with explicit signer (WASM provides private key)
            /// CRITICAL: Worker NEVER signs with its own key. WASM MUST provide signer credentials.
            /// signer-id: the account to sign as
            /// signer-key: the private key in NEAR format (ed25519:base58...)
            /// wait-until: same as send-tx (empty = "FINAL")
            /// Returns (tx_hash, error)
            pub fn call(
                signer_id: &str,
                signer_key: &str,
                receiver_id: &str,
                method_name: &str,
                args_json: &str,
                deposit_yocto: &str,
                gas: &str,
                wait_until: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = signer_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = signer_key;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = receiver_id;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let vec3 = method_name;
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    let vec4 = args_json;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    let vec5 = deposit_yocto;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    let vec6 = gas;
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    let vec7 = wait_until;
                    let ptr7 = vec7.as_ptr().cast::<u8>();
                    let len7 = vec7.len();
                    let ptr8 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "call"]
                        fn wit_import9(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import9(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import9(
                            ptr0.cast_mut(),
                            len0,
                            ptr1.cast_mut(),
                            len1,
                            ptr2.cast_mut(),
                            len2,
                            ptr3.cast_mut(),
                            len3,
                            ptr4.cast_mut(),
                            len4,
                            ptr5.cast_mut(),
                            len5,
                            ptr6.cast_mut(),
                            len6,
                            ptr7.cast_mut(),
                            len7,
                            ptr8,
                        )
                    };
                    let l10 = *ptr8.add(0).cast::<*mut u8>();
                    let l11 = *ptr8
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len12 = l11;
                    let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
                    let l13 = *ptr8
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l14 = *ptr8
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len15 = l14;
                    let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);
                    let result16 = (
                        _rt::string_lift(bytes12),
                        _rt::string_lift(bytes15),
                    );
                    result16
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Transfer NEAR tokens with explicit signer (WASM provides private key)
            /// CRITICAL: Worker NEVER signs with its own key. WASM MUST provide signer credentials.
            /// signer-id: the account to sign as
            /// signer-key: the private key in NEAR format (ed25519:base58...)
            /// wait-until: same as send-tx (empty = "FINAL")
            /// Returns (tx_hash, error)
            pub fn transfer(
                signer_id: &str,
                signer_key: &str,
                receiver_id: &str,
                amount_yocto: &str,
                wait_until: &str,
            ) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = signer_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = signer_key;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = receiver_id;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let vec3 = amount_yocto;
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    let vec4 = wait_until;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "transfer"]
                        fn wit_import6(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import6(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import6(
                            ptr0.cast_mut(),
                            len0,
                            ptr1.cast_mut(),
                            len1,
                            ptr2.cast_mut(),
                            len2,
                            ptr3.cast_mut(),
                            len3,
                            ptr4.cast_mut(),
                            len4,
                            ptr5,
                        )
                    };
                    let l7 = *ptr5.add(0).cast::<*mut u8>();
                    let l8 = *ptr5
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let l10 = *ptr5
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l11 = *ptr5
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len12 = l11;
                    let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
                    let result13 = (_rt::string_lift(bytes9), _rt::string_lift(bytes12));
                    result13
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// ==================== Network Methods ====================
            /// Get current gas price
            /// block-id: block height or hash (empty = latest)
            pub fn gas_price(block_id: &str) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = block_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "gas-price"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = *ptr1.add(0).cast::<*mut u8>();
                    let l4 = *ptr1
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    let l6 = *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *ptr1
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    let result9 = (_rt::string_lift(bytes5), _rt::string_lift(bytes8));
                    result9
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get node status (sync status, version, protocol)
            pub fn status() -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "status"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len4 = l3;
                    let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                    let l5 = *ptr0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l6 = *ptr0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len7 = l6;
                    let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                    let result8 = (_rt::string_lift(bytes4), _rt::string_lift(bytes7));
                    result8
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get network info (peers, connections)
            pub fn network_info() -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "network-info"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len4 = l3;
                    let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                    let l5 = *ptr0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l6 = *ptr0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len7 = l6;
                    let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                    let result8 = (_rt::string_lift(bytes4), _rt::string_lift(bytes7));
                    result8
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get validators for epoch
            /// epoch-id: specific epoch ID or empty for current validators
            pub fn validators(epoch_id: &str) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = epoch_id;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "validators"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = *ptr1.add(0).cast::<*mut u8>();
                    let l4 = *ptr1
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    let l6 = *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *ptr1
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    let result9 = (_rt::string_lift(bytes5), _rt::string_lift(bytes8));
                    result9
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// ==================== Low-level API ====================
            /// Raw JSON-RPC call (for any method not covered above)
            pub fn raw(method: &str, params_json: &str) -> (_rt::String, _rt::String) {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 4 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 4
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = method;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = params_json;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "near:rpc/api@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "raw"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = *ptr2.add(0).cast::<*mut u8>();
                    let l5 = *ptr2
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *ptr2
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let result10 = (_rt::string_lift(bytes6), _rt::string_lift(bytes9));
                    result10
                }
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    extern crate alloc as alloc_crate;
}
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:near:rpc@0.1.0:bot-father:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1025] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x80\x07\x01A\x02\x01\
A\x02\x01B#\x01o\x02ss\x01@\x04\x0bcontract-ids\x0bmethod-names\x09args-jsons\x11\
finality-or-blocks\0\0\x04\0\x04view\x01\x01\x01@\x02\x0aaccount-ids\x11finality\
-or-blocks\0\0\x04\0\x0cview-account\x01\x02\x01@\x03\x0aaccount-ids\x0apublic-k\
eys\x11finality-or-blocks\0\0\x04\0\x0fview-access-key\x01\x03\x04\0\x14view-acc\
ess-key-list\x01\x02\x04\0\x09view-code\x01\x02\x01@\x03\x0aaccount-ids\x0dprefi\
x-base64s\x11finality-or-blocks\0\0\x04\0\x0aview-state\x01\x04\x01@\x01\x11fina\
lity-or-blocks\0\0\x04\0\x05block\x01\x05\x01@\x01\x17chunk-id-or-block-shards\0\
\0\x04\0\x05chunk\x01\x06\x04\0\x07changes\x01\x05\x01@\x02\x10signed-tx-base64s\
\x0await-untils\0\0\x04\0\x07send-tx\x01\x07\x01@\x03\x07tx-hashs\x11sender-acco\
unt-ids\x0await-untils\0\0\x04\0\x09tx-status\x01\x08\x01@\x01\x0areceipt-ids\0\0\
\x04\0\x07receipt\x01\x09\x01@\x08\x09signer-ids\x0asigner-keys\x0breceiver-ids\x0b\
method-names\x09args-jsons\x0ddeposit-yoctos\x03gass\x0await-untils\0\0\x04\0\x04\
call\x01\x0a\x01@\x05\x09signer-ids\x0asigner-keys\x0breceiver-ids\x0camount-yoc\
tos\x0await-untils\0\0\x04\0\x08transfer\x01\x0b\x01@\x01\x08block-ids\0\0\x04\0\
\x09gas-price\x01\x0c\x01@\0\0\0\x04\0\x06status\x01\x0d\x04\0\x0cnetwork-info\x01\
\x0d\x01@\x01\x08epoch-ids\0\0\x04\0\x0avalidators\x01\x0e\x01@\x02\x06methods\x0b\
params-jsons\0\0\x04\0\x03raw\x01\x0f\x03\0\x12near:rpc/api@0.1.0\x05\0\x04\0\x19\
near:rpc/bot-father@0.1.0\x04\0\x0b\x10\x01\0\x0abot-father\x03\0\0\0G\x09produc\
ers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060\
.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
